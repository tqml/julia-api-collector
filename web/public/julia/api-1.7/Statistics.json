{
  "julia": "1.7.3",
  "methods": [
    {
      "name": "cor",
      "arg_names": ["x"],
      "arg_types": ["AbstractVector{T}"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\ncor(x::AbstractVector)\n```\n\nReturn the number one.\n"
    },
    {
      "name": "cor",
      "arg_names": ["X"],
      "arg_types": ["AbstractMatrix"],
      "kwarg_names": ["dims"],
      "module": "Statistics",
      "doc": "```\ncor(x::AbstractVector)\n```\n\nReturn the number one.\n\n```\ncor(X::AbstractMatrix; dims::Int=1)\n```\n\nCompute the Pearson correlation matrix of the matrix `X` along the dimension `dims`.\n"
    },
    {
      "name": "cor",
      "arg_names": ["x", "y"],
      "arg_types": ["AbstractVector", "AbstractVector"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\ncor(x::AbstractVector, y::AbstractVector)\n```\n\nCompute the Pearson correlation between the vectors `x` and `y`.\n\n```\ncor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)\n```\n\nCompute the Pearson correlation between the vectors or matrices `X` and `Y` along the dimension `dims`.\n"
    },
    {
      "name": "cor",
      "arg_names": ["x", "y"],
      "arg_types": ["AbstractVecOrMat", "AbstractVecOrMat"],
      "kwarg_names": ["dims"],
      "module": "Statistics",
      "doc": "```\ncor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)\n```\n\nCompute the Pearson correlation between the vectors or matrices `X` and `Y` along the dimension `dims`.\n"
    },
    {
      "name": "cov",
      "arg_names": ["X"],
      "arg_types": ["SparseArrays.SparseMatrixCSC"],
      "kwarg_names": ["dims", "corrected"],
      "module": "Statistics",
      "doc": "```\ncov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)\n```\n\nCompute the covariance matrix of the matrix `X` along the dimension `dims`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = size(X, dims)`.\n"
    },
    {
      "name": "cov",
      "arg_names": ["x"],
      "arg_types": ["AbstractVector"],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\ncov(x::AbstractVector; corrected::Bool=true)\n```\n\nCompute the variance of the vector `x`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = length(x)`.\n"
    },
    {
      "name": "cov",
      "arg_names": ["X"],
      "arg_types": ["AbstractMatrix"],
      "kwarg_names": ["dims", "corrected"],
      "module": "Statistics",
      "doc": "```\ncov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)\n```\n\nCompute the covariance matrix of the matrix `X` along the dimension `dims`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = size(X, dims)`.\n"
    },
    {
      "name": "cov",
      "arg_names": ["x", "y"],
      "arg_types": ["AbstractVector", "AbstractVector"],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\ncov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)\n```\n\nCompute the covariance between the vectors `x` and `y`. If `corrected` is `true` (the default), computes $\\frac{1}{n-1}\\sum_{i=1}^n (x_i-\\bar x) (y_i-\\bar y)^*$ where $*$ denotes the complex conjugate and `n = length(x) = length(y)`. If `corrected` is `false`, computes $\\frac{1}{n}\\sum_{i=1}^n (x_i-\\bar x) (y_i-\\bar y)^*$.\n\n```\ncov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)\n```\n\nCompute the covariance between the vectors or matrices `X` and `Y` along the dimension `dims`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = size(X, dims) = size(Y, dims)`.\n"
    },
    {
      "name": "cov",
      "arg_names": ["X", "Y"],
      "arg_types": ["AbstractVecOrMat", "AbstractVecOrMat"],
      "kwarg_names": ["dims", "corrected"],
      "module": "Statistics",
      "doc": "```\ncov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)\n```\n\nCompute the covariance between the vectors or matrices `X` and `Y` along the dimension `dims`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = size(X, dims) = size(Y, dims)`.\n"
    },
    {
      "name": "mean",
      "arg_names": ["r"],
      "arg_types": ["AbstractRange{<:Real}"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmean(itr)\n```\n\nCompute the mean of all elements in a collection.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the mean of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n```\n\n```\nmean(A::AbstractArray; dims)\n```\n\nCompute the mean of an array over the given dimensions.\n\n!!! compat \"Julia 1.1\"\n    `mean` for empty arrays requires at least Julia 1.1.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean(A, dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\njulia> mean(A, dims=2)\n2×1 Matrix{Float64}:\n 1.5\n 3.5\n```\n"
    },
    {
      "name": "mean",
      "arg_names": ["A"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": ["dims"],
      "module": "Statistics",
      "doc": "```\nmean(itr)\n```\n\nCompute the mean of all elements in a collection.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the mean of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n```\n\n```\nmean(A::AbstractArray; dims)\n```\n\nCompute the mean of an array over the given dimensions.\n\n!!! compat \"Julia 1.1\"\n    `mean` for empty arrays requires at least Julia 1.1.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean(A, dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\njulia> mean(A, dims=2)\n2×1 Matrix{Float64}:\n 1.5\n 3.5\n```\n"
    },
    {
      "name": "mean",
      "arg_names": ["itr"],
      "arg_types": [""],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmean(itr)\n```\n\nCompute the mean of all elements in a collection.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the mean of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n```\n"
    },
    {
      "name": "mean",
      "arg_names": ["f", "A"],
      "arg_types": ["", "AbstractArray"],
      "kwarg_names": ["dims"],
      "module": "Statistics",
      "doc": "```\nmean(f::Function, itr)\n```\n\nApply the function `f` to each element of collection `itr` and take the mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n```\n\n```\nmean(f::Function, A::AbstractArray; dims)\n```\n\nApply the function `f` to each element of array `A` and take the mean over dimensions `dims`.\n\n!!! compat \"Julia 1.3\"\n    This method requires at least Julia 1.3.\n\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\njulia> mean(√, [1 2 3; 4 5 6], dims=2)\n2×1 Matrix{Float64}:\n 1.3820881233139908\n 2.2285192400943226\n```\n"
    },
    {
      "name": "mean",
      "arg_names": ["f", "itr"],
      "arg_types": ["", ""],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmean(f::Function, itr)\n```\n\nApply the function `f` to each element of collection `itr` and take the mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n```\n"
    },
    {
      "name": "mean!",
      "arg_names": ["R", "A"],
      "arg_types": ["AbstractArray", "AbstractArray"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmean!(r, v)\n```\n\nCompute the mean of `v` over the singleton dimensions of `r`, and write results to `r`.\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> v = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean!([1., 1.], v)\n2-element Vector{Float64}:\n 1.5\n 3.5\n\njulia> mean!([1. 1.], v)\n1×2 Matrix{Float64}:\n 2.0  3.0\n```\n"
    },
    {
      "name": "median",
      "arg_names": ["r"],
      "arg_types": ["AbstractRange{<:Real}"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmedian(itr)\n```\n\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if `itr` contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the median of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n```\n\n```\nmedian(A::AbstractArray; dims)\n```\n\nCompute the median of an array along the given dimensions.\n\n# Examples\n\n```jl\njulia> using Statistics\n\njulia> median([1 2; 3 4], dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n```\n"
    },
    {
      "name": "median",
      "arg_names": ["v"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": ["dims"],
      "module": "Statistics",
      "doc": "```\nmedian(itr)\n```\n\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if `itr` contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the median of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n```\n\n```\nmedian(A::AbstractArray; dims)\n```\n\nCompute the median of an array along the given dimensions.\n\n# Examples\n\n```jl\njulia> using Statistics\n\njulia> median([1 2; 3 4], dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n```\n"
    },
    {
      "name": "median",
      "arg_names": ["itr"],
      "arg_types": [""],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmedian(itr)\n```\n\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\n!!! note\n    If `itr` contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if `itr` contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the median of non-missing values.\n\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n```\n"
    },
    {
      "name": "median!",
      "arg_names": ["v"],
      "arg_types": ["AbstractVector"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmedian!(v)\n```\n\nLike [`median`](@ref), but may overwrite the input vector.\n"
    },
    {
      "name": "median!",
      "arg_names": ["v"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmedian!(v)\n```\n\nLike [`median`](@ref), but may overwrite the input vector.\n"
    },
    {
      "name": "middle",
      "arg_names": ["x"],
      "arg_types": [
        "Union{Bool, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}"
      ],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(x)\n```\n\nCompute the middle of a scalar value, which is equivalent to `x` itself, but of the type of `middle(x, x)` for consistency.\n"
    },
    {
      "name": "middle",
      "arg_names": ["x"],
      "arg_types": ["AbstractFloat"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(x)\n```\n\nCompute the middle of a scalar value, which is equivalent to `x` itself, but of the type of `middle(x, x)` for consistency.\n\n```\nmiddle(x, y)\n```\n\nCompute the middle of two numbers `x` and `y`, which is equivalent in both value and type to computing their mean (`(x + y) / 2`).\n\n```\nmiddle(range)\n```\n\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\n\n```jldoctest\njulia> using Statistics\n\njulia> middle(1:10)\n5.5\n```\n\n```\nmiddle(a)\n```\n\nCompute the middle of an array `a`, which consists of finding its extrema and then computing their mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> a = [1,2,3.6,10.9]\n4-element Vector{Float64}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n```\n"
    },
    {
      "name": "middle",
      "arg_names": ["x"],
      "arg_types": ["Number"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(x)\n```\n\nCompute the middle of a scalar value, which is equivalent to `x` itself, but of the type of `middle(x, x)` for consistency.\n\n```\nmiddle(x, y)\n```\n\nCompute the middle of two numbers `x` and `y`, which is equivalent in both value and type to computing their mean (`(x + y) / 2`).\n\n```\nmiddle(range)\n```\n\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\n\n```jldoctest\njulia> using Statistics\n\njulia> middle(1:10)\n5.5\n```\n\n```\nmiddle(a)\n```\n\nCompute the middle of an array `a`, which consists of finding its extrema and then computing their mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> a = [1,2,3.6,10.9]\n4-element Vector{Float64}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n```\n"
    },
    {
      "name": "middle",
      "arg_names": ["x", "y"],
      "arg_types": ["Number", "Number"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(x, y)\n```\n\nCompute the middle of two numbers `x` and `y`, which is equivalent in both value and type to computing their mean (`(x + y) / 2`).\n"
    },
    {
      "name": "middle",
      "arg_names": ["a"],
      "arg_types": ["AbstractRange"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(range)\n```\n\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\n\n```jldoctest\njulia> using Statistics\n\njulia> middle(1:10)\n5.5\n```\n\n```\nmiddle(a)\n```\n\nCompute the middle of an array `a`, which consists of finding its extrema and then computing their mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> a = [1,2,3.6,10.9]\n4-element Vector{Float64}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n```\n"
    },
    {
      "name": "middle",
      "arg_names": ["a"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nmiddle(a)\n```\n\nCompute the middle of an array `a`, which consists of finding its extrema and then computing their mean.\n\n```jldoctest\njulia> using Statistics\n\njulia> a = [1,2,3.6,10.9]\n4-element Vector{Float64}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n```\n"
    },
    {
      "name": "quantile",
      "arg_names": ["v", "p"],
      "arg_types": ["AbstractVector", ""],
      "kwarg_names": ["sorted", "alpha", "beta"],
      "module": "Statistics",
      "doc": "```\nquantile(itr, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n```\n\nCompute the quantile(s) of a collection `itr` at a specified probability or vector or tuple of probabilities `p` on the interval [0,1]. The keyword argument `sorted` indicates whether `itr` can be assumed to be sorted.\n\nSamples quantile are defined by `Q(p) = (1-γ)*x[j] + γ*x[j+1]`, where $x[j]$ is the j-th order statistic, and `γ` is a function of `j = floor(n*p + m)`, `m = alpha + p*(1 - alpha - beta)` and `g = n*p + m - j`.\n\nBy default (`alpha = beta = 1`), quantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`, for `k = 1:n` where `n = length(itr)`. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments `alpha` and `beta` correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\n  * Def. 4: `alpha=0`, `beta=1`\n  * Def. 5: `alpha=0.5`, `beta=0.5`\n  * Def. 6: `alpha=0`, `beta=0` (Excel `PERCENTILE.EXC`, Python default, Stata `altdef`)\n  * Def. 7: `alpha=1`, `beta=1` (Julia, R and NumPy default, Excel `PERCENTILE` and `PERCENTILE.INC`, Python `'inclusive'`)\n  * Def. 8: `alpha=1/3`, `beta=1/3`\n  * Def. 9: `alpha=3/8`, `beta=3/8`\n\n!!! note\n    An `ArgumentError` is thrown if `v` contains `NaN` or [`missing`](@ref) values. Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the quantiles of non-missing values.\n\n\n# References\n\n  * Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n  * [Quantile on Wikipedia](https://en.m.wikipedia.org/wiki/Quantile) details the different quantile definitions\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> quantile(0:20, 0.5)\n10.0\n\njulia> quantile(0:20, [0.1, 0.5, 0.9])\n3-element Vector{Float64}:\n  2.0\n 10.0\n 18.000000000000004\n\njulia> quantile(skipmissing([1, 10, missing]), 0.5)\n5.5\n```\n"
    },
    {
      "name": "quantile",
      "arg_names": ["itr", "p"],
      "arg_types": ["", ""],
      "kwarg_names": ["sorted", "alpha", "beta"],
      "module": "Statistics",
      "doc": "```\nquantile(itr, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n```\n\nCompute the quantile(s) of a collection `itr` at a specified probability or vector or tuple of probabilities `p` on the interval [0,1]. The keyword argument `sorted` indicates whether `itr` can be assumed to be sorted.\n\nSamples quantile are defined by `Q(p) = (1-γ)*x[j] + γ*x[j+1]`, where $x[j]$ is the j-th order statistic, and `γ` is a function of `j = floor(n*p + m)`, `m = alpha + p*(1 - alpha - beta)` and `g = n*p + m - j`.\n\nBy default (`alpha = beta = 1`), quantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`, for `k = 1:n` where `n = length(itr)`. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments `alpha` and `beta` correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\n  * Def. 4: `alpha=0`, `beta=1`\n  * Def. 5: `alpha=0.5`, `beta=0.5`\n  * Def. 6: `alpha=0`, `beta=0` (Excel `PERCENTILE.EXC`, Python default, Stata `altdef`)\n  * Def. 7: `alpha=1`, `beta=1` (Julia, R and NumPy default, Excel `PERCENTILE` and `PERCENTILE.INC`, Python `'inclusive'`)\n  * Def. 8: `alpha=1/3`, `beta=1/3`\n  * Def. 9: `alpha=3/8`, `beta=3/8`\n\n!!! note\n    An `ArgumentError` is thrown if `v` contains `NaN` or [`missing`](@ref) values. Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the quantiles of non-missing values.\n\n\n# References\n\n  * Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n  * [Quantile on Wikipedia](https://en.m.wikipedia.org/wiki/Quantile) details the different quantile definitions\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> quantile(0:20, 0.5)\n10.0\n\njulia> quantile(0:20, [0.1, 0.5, 0.9])\n3-element Vector{Float64}:\n  2.0\n 10.0\n 18.000000000000004\n\njulia> quantile(skipmissing([1, 10, missing]), 0.5)\n5.5\n```\n"
    },
    {
      "name": "quantile!",
      "arg_names": ["q", "v", "p"],
      "arg_types": ["AbstractArray", "AbstractVector", "AbstractArray"],
      "kwarg_names": ["sorted", "alpha", "beta"],
      "module": "Statistics",
      "doc": "```\nquantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n```\n\nCompute the quantile(s) of a vector `v` at a specified probability or vector or tuple of probabilities `p` on the interval [0,1]. If `p` is a vector, an optional output array `q` may also be specified. (If not provided, a new output array is created.) The keyword argument `sorted` indicates whether `v` can be assumed to be sorted; if `false` (the default), then the elements of `v` will be partially sorted in-place.\n\nBy default (`alpha = beta = 1`), quantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`, for `k = 1:n` where `n = length(v)`. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments `alpha` and `beta` correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\n  * Def. 4: `alpha=0`, `beta=1`\n  * Def. 5: `alpha=0.5`, `beta=0.5`\n  * Def. 6: `alpha=0`, `beta=0` (Excel `PERCENTILE.EXC`, Python default, Stata `altdef`)\n  * Def. 7: `alpha=1`, `beta=1` (Julia, R and NumPy default, Excel `PERCENTILE` and `PERCENTILE.INC`, Python `'inclusive'`)\n  * Def. 8: `alpha=1/3`, `beta=1/3`\n  * Def. 9: `alpha=3/8`, `beta=3/8`\n\n!!! note\n    An `ArgumentError` is thrown if `v` contains `NaN` or [`missing`](@ref) values.\n\n\n# References\n\n  * Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n  * [Quantile on Wikipedia](https://en.m.wikipedia.org/wiki/Quantile) details the different quantile definitions\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> x = [3, 2, 1];\n\njulia> quantile!(x, 0.5)\n2.0\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> y = zeros(3);\n\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\ntrue\n\njulia> y\n3-element Vector{Float64}:\n 1.2000000000000002\n 2.0\n 2.8000000000000003\n```\n"
    },
    {
      "name": "quantile!",
      "arg_names": ["v", "p"],
      "arg_types": [
        "AbstractVector",
        "Union{Tuple{Vararg{Real}}, AbstractArray}"
      ],
      "kwarg_names": ["sorted", "alpha", "beta"],
      "module": "Statistics",
      "doc": "```\nquantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n```\n\nCompute the quantile(s) of a vector `v` at a specified probability or vector or tuple of probabilities `p` on the interval [0,1]. If `p` is a vector, an optional output array `q` may also be specified. (If not provided, a new output array is created.) The keyword argument `sorted` indicates whether `v` can be assumed to be sorted; if `false` (the default), then the elements of `v` will be partially sorted in-place.\n\nBy default (`alpha = beta = 1`), quantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`, for `k = 1:n` where `n = length(v)`. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments `alpha` and `beta` correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\n  * Def. 4: `alpha=0`, `beta=1`\n  * Def. 5: `alpha=0.5`, `beta=0.5`\n  * Def. 6: `alpha=0`, `beta=0` (Excel `PERCENTILE.EXC`, Python default, Stata `altdef`)\n  * Def. 7: `alpha=1`, `beta=1` (Julia, R and NumPy default, Excel `PERCENTILE` and `PERCENTILE.INC`, Python `'inclusive'`)\n  * Def. 8: `alpha=1/3`, `beta=1/3`\n  * Def. 9: `alpha=3/8`, `beta=3/8`\n\n!!! note\n    An `ArgumentError` is thrown if `v` contains `NaN` or [`missing`](@ref) values.\n\n\n# References\n\n  * Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n  * [Quantile on Wikipedia](https://en.m.wikipedia.org/wiki/Quantile) details the different quantile definitions\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> x = [3, 2, 1];\n\njulia> quantile!(x, 0.5)\n2.0\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> y = zeros(3);\n\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\ntrue\n\njulia> y\n3-element Vector{Float64}:\n 1.2000000000000002\n 2.0\n 2.8000000000000003\n```\n"
    },
    {
      "name": "quantile!",
      "arg_names": ["v", "p"],
      "arg_types": ["AbstractVector", "Real"],
      "kwarg_names": ["sorted", "alpha", "beta"],
      "module": "Statistics",
      "doc": "```\nquantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n```\n\nCompute the quantile(s) of a vector `v` at a specified probability or vector or tuple of probabilities `p` on the interval [0,1]. If `p` is a vector, an optional output array `q` may also be specified. (If not provided, a new output array is created.) The keyword argument `sorted` indicates whether `v` can be assumed to be sorted; if `false` (the default), then the elements of `v` will be partially sorted in-place.\n\nBy default (`alpha = beta = 1`), quantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`, for `k = 1:n` where `n = length(v)`. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments `alpha` and `beta` correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\n  * Def. 4: `alpha=0`, `beta=1`\n  * Def. 5: `alpha=0.5`, `beta=0.5`\n  * Def. 6: `alpha=0`, `beta=0` (Excel `PERCENTILE.EXC`, Python default, Stata `altdef`)\n  * Def. 7: `alpha=1`, `beta=1` (Julia, R and NumPy default, Excel `PERCENTILE` and `PERCENTILE.INC`, Python `'inclusive'`)\n  * Def. 8: `alpha=1/3`, `beta=1/3`\n  * Def. 9: `alpha=3/8`, `beta=3/8`\n\n!!! note\n    An `ArgumentError` is thrown if `v` contains `NaN` or [`missing`](@ref) values.\n\n\n# References\n\n  * Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n  * [Quantile on Wikipedia](https://en.m.wikipedia.org/wiki/Quantile) details the different quantile definitions\n\n# Examples\n\n```jldoctest\njulia> using Statistics\n\njulia> x = [3, 2, 1];\n\njulia> quantile!(x, 0.5)\n2.0\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> y = zeros(3);\n\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\ntrue\n\njulia> y\n3-element Vector{Float64}:\n 1.2000000000000002\n 2.0\n 2.8000000000000003\n```\n"
    },
    {
      "name": "std",
      "arg_names": ["A"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": ["corrected", "mean", "dims"],
      "module": "Statistics",
      "doc": "```\nstd(itr; corrected::Bool=true, mean=nothing[, dims])\n```\n\nCompute the sample standard deviation of collection `itr`.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the standard deviation over dimensions, and `means` may contain means for each dimension of `itr`.\n\nA pre-computed `mean` may be provided. When `dims` is specified, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the standard deviation of non-missing values.\n\n"
    },
    {
      "name": "std",
      "arg_names": ["iterable"],
      "arg_types": [""],
      "kwarg_names": ["corrected", "mean"],
      "module": "Statistics",
      "doc": "```\nstd(itr; corrected::Bool=true, mean=nothing[, dims])\n```\n\nCompute the sample standard deviation of collection `itr`.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the standard deviation over dimensions, and `means` may contain means for each dimension of `itr`.\n\nA pre-computed `mean` may be provided. When `dims` is specified, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the standard deviation of non-missing values.\n\n"
    },
    {
      "name": "stdm",
      "arg_names": ["A", "m"],
      "arg_types": ["AbstractArray", ""],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\nstdm(itr, mean; corrected::Bool=true)\n```\n\nCompute the sample standard deviation of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the standard deviation over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the standard deviation of non-missing values.\n\n"
    },
    {
      "name": "stdm",
      "arg_names": ["iterable", "m"],
      "arg_types": ["", ""],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\nstdm(itr, mean; corrected::Bool=true)\n```\n\nCompute the sample standard deviation of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the standard deviation over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the standard deviation of non-missing values.\n\n"
    },
    {
      "name": "var",
      "arg_names": ["v"],
      "arg_types": ["AbstractRange"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nvar(itr; corrected::Bool=true, mean=nothing[, dims])\n```\n\nCompute the sample variance of collection `itr`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n` is the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions.\n\nA pre-computed `mean` may be provided. When `dims` is specified, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "var",
      "arg_names": ["A"],
      "arg_types": ["AbstractArray"],
      "kwarg_names": ["corrected", "mean", "dims"],
      "module": "Statistics",
      "doc": "```\nvar(itr; corrected::Bool=true, mean=nothing[, dims])\n```\n\nCompute the sample variance of collection `itr`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n` is the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions.\n\nA pre-computed `mean` may be provided. When `dims` is specified, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "var",
      "arg_names": ["iterable"],
      "arg_types": [""],
      "kwarg_names": ["corrected", "mean"],
      "module": "Statistics",
      "doc": "```\nvar(itr; corrected::Bool=true, mean=nothing[, dims])\n```\n\nCompute the sample variance of collection `itr`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1))`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n` is the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions.\n\nA pre-computed `mean` may be provided. When `dims` is specified, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "varm",
      "arg_names": ["v", "m"],
      "arg_types": ["AbstractRange", "AbstractArray"],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nvarm(itr, mean; dims, corrected::Bool=true)\n```\n\nCompute the sample variance of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1)`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "varm",
      "arg_names": ["A", "m"],
      "arg_types": ["AbstractArray", "AbstractArray"],
      "kwarg_names": ["corrected", "dims"],
      "module": "Statistics",
      "doc": "```\nvarm(itr, mean; dims, corrected::Bool=true)\n```\n\nCompute the sample variance of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1)`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "varm",
      "arg_names": ["v", "m"],
      "arg_types": ["AbstractRange", ""],
      "kwarg_names": [],
      "module": "Statistics",
      "doc": "```\nvarm(itr, mean; dims, corrected::Bool=true)\n```\n\nCompute the sample variance of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1)`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "varm",
      "arg_names": ["A", "m"],
      "arg_types": ["AbstractArray", ""],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\nvarm(itr, mean; dims, corrected::Bool=true)\n```\n\nCompute the sample variance of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1)`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    },
    {
      "name": "varm",
      "arg_names": ["iterable", "m"],
      "arg_types": ["", ""],
      "kwarg_names": ["corrected"],
      "module": "Statistics",
      "doc": "```\nvarm(itr, mean; dims, corrected::Bool=true)\n```\n\nCompute the sample variance of collection `itr`, with known mean(s) `mean`.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of `itr` is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating `sum((itr .- mean(itr)).^2) / (length(itr) - 1)`. If `corrected` is `true`, then the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` with `n` the number of elements in `itr`.\n\nIf `itr` is an `AbstractArray`, `dims` can be provided to compute the variance over dimensions. In that case, `mean` must be an array with the same shape as `mean(itr, dims=dims)` (additional trailing singleton dimensions are allowed).\n\n!!! note\n    If array contains `NaN` or [`missing`](@ref) values, the result is also `NaN` or `missing` (`missing` takes precedence if array contains both). Use the [`skipmissing`](@ref) function to omit `missing` entries and compute the variance of non-missing values.\n\n"
    }
  ]
}
